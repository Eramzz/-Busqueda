#ifndef QUERY_H
#define QUERY_H
#include <stdbool.h>

typedef enum {
    INCLUDE,
    EXCLUDE,
    OR
} QueryItemType;

typedef struct QueryItem {
    QueryItemType type;
    char** words; // For OR queries, this is an array
    int word_count;
    struct QueryItem* next;
} QueryItem;

typedef struct Query {
    QueryItem* head;
    int size;
} Query;

Query* queryInit(char* query_str);
void queryFree(Query* query);
DocumentsList* searchDocumentsWithQuery(ReverseIndex* index, Query* query);
DocumentsList* documentsListSortedDescending(DocumentsList* list, DocumentGraph* graph);

#endif



#include "query.h"
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

Query* queryInit(char* query_str) {
    if (!query_str) return NULL;
    
    Query* query = (Query*)malloc(sizeof(Query));
    if (!query) return NULL;
    
    query->head = NULL;
    query->size = 0;
    
    char* copy = strdup(query_str);
    char* token = strtok(copy, " ");
    
    while (token) {
        QueryItem* item = (QueryItem*)malloc(sizeof(QueryItem));
        if (!item) {
            free(copy);
            queryFree(query);
            return NULL;
        }
        
        if (token[0] == '-') {
            // Exclusion term
            item->type = EXCLUDE;
            item->words = (char**)malloc(sizeof(char*));
            item->words[0] = strdup(token + 1);
            item->word_count = 1;
        } else if (token[0] == '(') {
            // OR condition
            item->type = OR;
            item->word_count = 0;
            item->words = NULL;
            
            // Parse OR condition (simplified)
            char* or_part = token + 1;
            char* pipe = strchr(or_part, '|');
            char* end = strchr(or_part, ')');
            
            if (pipe && end) {
                *pipe = '\0';
                *end = '\0';
                
                item->word_count = 2;
                item->words = (char**)malloc(2 * sizeof(char*));
                item->words[0] = strdup(or_part);
                item->words[1] = strdup(pipe + 1);
            }
        } else {
            // Include term
            item->type = INCLUDE;
            item->words = (char**)malloc(sizeof(char*));
            item->words[0] = strdup(token);
            item->word_count = 1;
        }
        
        item->next = query->head;
        query->head = item;
        query->size++;
        
        token = strtok(NULL, " ");
    }
    
    free(copy);
    return query;
}

void queryFree(Query* query) {
    if (!query) return;
    
    QueryItem* current = query->head;
    while (current) {
        QueryItem* next = current->next;
        
        for (int i = 0; i < current->word_count; i++) {
            free(current->words[i]);
        }
        free(current->words);
        free(current);
        
        current = next;
    }
    
    free(query);
}

DocumentsList* searchDocumentsWithQuery(ReverseIndex* index, Query* query) {
    if (!index || !query) return NULL;
    
    DocumentsList* result = (DocumentsList*)malloc(sizeof(DocumentsList));
    if (!result) return NULL;
    
    result->head = NULL;
    result->size = 0;
    
    QueryItem* item = query->head;
    while (item) {
        if (item->type == INCLUDE) {
            for (int i = 0; i < item->word_count; i++) {
                DocumentsList* docs = reverseIndexGet(index, item->words[i]);
                if (docs) {
                    // Intersect with current result
                    if (result->size == 0) {
                        // First term - add all documents
                        Document* current = docs->head;
                        while (current) {
                            Document* new_doc = (Document*)malloc(sizeof(Document));
                            if (new_doc) {
                                new_doc->id = current->id;
                                new_doc->title = strdup(current->title);
                                new_doc->body = NULL;
                                new_doc->links = NULL;
                                new_doc->relevance_score = 0.0f;
                                new_doc->next = result->head;
                                result->head = new_doc;
                                result->size++;
                            }
                            current = current->next;
                        }
                    } else {
                        // Subsequent terms - intersect
                        DocumentsList* new_result = (DocumentsList*)malloc(sizeof(DocumentsList));
                        new_result->head = NULL;
                        new_result->size = 0;
                        
                        Document* current = docs->head;
                        while (current) {
                            Document* existing = result->head;
                            while (existing) {
                                if (existing->id == current->id) {
                                    Document* new_doc = (Document*)malloc(sizeof(Document));
                                    if (new_doc) {
                                        new_doc->id = current->id;
                                        new_doc->title = strdup(current->title);
                                        new_doc->body = NULL;
                                        new_doc->links = NULL;
                                        new_doc->relevance_score = 0.0f;
                                        new_doc->next = new_result->head;
                                        new_result->head = new_doc;
                                        new_result->size++;
                                    }
                                    break;
                                }
                                existing = existing->next;
                            }
                            current = current->next;
                        }
                        
                        // Free old result and replace with new
                        documentsListFree(result);
                        free(result);
                        result = new_result;
                    }
                } else {
                    // No documents for this term - empty result
                    documentsListFree(result);
                    free(result);
                    return NULL;
                }
            }
        }
        item = item->next;
    }
    
    // Handle exclusions
    item = query->head;
    while (item) {
        if (item->type == EXCLUDE) {
            for (int i = 0; i < item->word_count; i++) {
                DocumentsList* docs = reverseIndexGet(index, item->words[i]);
                if (docs) {
                    // Remove excluded documents
                    Document* current = docs->head;
                    while (current) {
                        Document* prev = NULL;
                        Document* curr = result->head;
                        while (curr) {
                            if (curr->id == current->id) {
                                if (prev) {
                                    prev->next = curr->next;
                                } else {
                                    result->head = curr->next;
                                }
                                Document* to_free = curr;
                                curr = curr->next;
                                documentFree(to_free);
                                result->size--;
                            } else {
                                prev = curr;
                                curr = curr->next;
                            }
                        }
                        current = current->next;
                    }
                }
            }
        }
        item = item->next;
    }
    
    return result;
}

DocumentsList* documentsListSortedDescending(DocumentsList* list, DocumentGraph* graph) {
    if (!list || list->size <= 1) return list;
    
    // Convert to array for sorting
    Document** array = (Document**)malloc(list->size * sizeof(Document*));
    if (!array) return list;
    
    Document* current = list->head;
    for (int i = 0; i < list->size; i++) {
        array[i] = current;
        current = current->next;
    }
    
    // Simple bubble sort (would be better with a more efficient algorithm)
    for (int i = 0; i < list->size - 1; i++) {
        for (int j = 0; j < list->size - i - 1; j++) {
            float score1 = graph ? graphGetIndegree(graph, array[j]->id) : 0.0f;
            float score2 = graph ? graphGetIndegree(graph, array[j+1]->id) : 0.0f;
            
            if (score1 < score2) {
                Document* temp = array[j];
                array[j] = array[j+1];
                array[j+1] = temp;
            }
        }
    }
    
    // Rebuild the list
    list->head = array[0];
    for (int i = 0; i < list->size - 1; i++) {
        array[i]->next = array[i+1];
    }
    array[list->size-1]->next = NULL;
    
    free(array);
    return list;
}
